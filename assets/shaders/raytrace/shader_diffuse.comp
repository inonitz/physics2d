#version 460 core
layout(local_size_x =    , local_size_y =    , local_size_z =    ) in;
layout(rgba32f, binding = 0) writeonly restrict uniform image2D imageOut;


layout(location = 2) uniform vec4  u_dt;
layout(location = 3) uniform int   u_samplesPpx;
layout(location = 4) uniform int   u_recurseDepth;
layout(location = 5) uniform int   u_scatterFactor;
layout(location = 6) uniform float u_scatterBase;


struct Ray
{
    vec3 origin;
    vec3 dir;
};
struct Sphere 
{ 
    vec4 pos_radius; 
};
struct CameraTransform
{
    vec3  position;
    vec2  viewport;
    float focal_length; /* Distance from camera origin to camera Screen */
    uint  reserved;
};


layout(std430, binding=1) buffer SceneData
{
    CameraTransform sceneCameraTransform;
    uint            sceneObjMaxLength;
    uint            sceneObjCurrLength;
    uint            reserved[2];
    Sphere          sceneObject[];
};


vec3 rayAt(in Ray ray, in float t) { return ray.origin + ray.dir * t; }
Ray  cameraGetRay(CameraTransform cam, vec3 rayOrigin, vec2 uv) /* Camera pointing towards -Z axis */
{
    vec3 rayDir;
    rayDir = cam.position - vec3( (vec2(0.5f) - uv) * cam.viewport, cam.focal_length);
    return Ray(rayOrigin, rayDir);
}





/* Using trascendenal constants for fun & profit */
const float c_infinity = 1. / 0.;
const float c_pi         = 3.14159265358979323846264338327950288;
const float c_sqrt2      = 1.41421356237309504880;
const float c_sqrt3      = 1.73205080756887729352;
const float c_phi        = 1.61803398874989484820;
const float c_ramanujan  = 262537412640768743.999999999999250073; /* e^( pi * sqrt(163) )*/
const float c_atan2      = 0.955316618124509278163;
const float c_chaitin    = 0.0078749969978123844;                 /* avg prob that a rand program will halt */
const float c_feigenbaum = 2.50290787509589282228;

float degrees_to_radians(float degrees) { return degrees * c_pi / 180.0f; }




uint pcg_hash(in uint x)
{
    x = x * 747796405u + 2891336453u;
    uint word = ((x >> ((x >> 28u) + 4u)) ^ x) * 277803737u;
    return (word >> 22u) ^ word;
}


float random( vec2 p )
{
    const vec2 r = vec2(23.1406926327792690, 2.6651441426902251);
    return fract( cos( mod( 123456789., 1e-7 + 256. * dot(p,r) ) ) );  
}


float uintToNormFloat(uint m) { 
    return uintBitsToFloat((m & 0x007FFFFFu) | 0x3F800000u ) - 1.0f; 
}


float random_norm(vec2 p) {
    return uintToNormFloat(floatBitsToUint(random(p)));
}


vec3 simpleRandUnitSphere(in vec2 texelCoord, uint sampleNum)
{
    vec3 r3 = vec3(
        random(  vec2(u_dt.x, random(texelCoord)       )),
        random(  vec2(u_dt.y, random(vec2(sampleNum))  )), 
        0
    );
    r3.z = random(r3.xy);
    return normalize(r3);
}




struct SphereRayIntersectionResult
{
    float t;
    vec3  normal;
};


void intersection(
    in  Ray    R, 
    in  Sphere S, 
    in  vec2   t_bounds, 
    out SphereRayIntersectionResult 
    result
) {
    float a, b, ac, discrim;
    vec3 tmp;
    vec2 coef;


    tmp = R.origin - S.pos_radius.xyz;
    b = -1.0f * dot(R.dir, tmp); /* calculate -b */
    a = dot(R.dir, R.dir);
    ac = dot(tmp, tmp) - S.pos_radius.w * S.pos_radius.w;

    b  *= (1.0f / a);
    ac *= (1.0f / a);
    discrim = b * b - ac;

    result.t = float(discrim < 0.0f) * c_infinity;
    if(isinf(result.t))
        return;


    coef = vec2(
        b + sqrt(discrim),
        b - sqrt(discrim)
    );
    coef = mix(vec2(c_infinity), coef, 
        bvec2(
            t_bounds.x < coef.x && coef.x < t_bounds.y,
            t_bounds.x < coef.y && coef.y < t_bounds.y
        )
    );
    result.t = min(coef.x, coef.y);
    if(isinf(result.t))
        return;


    result.normal  = rayAt(R, result.t) - S.pos_radius.xyz;
    result.normal *= (1.0f / S.pos_radius.w);
    result.normal *= mix(-1.0f, 1.0f, dot(R.dir, result.normal) < 0.0f); /* set proper direction if vector is outwards/inwards */
    // result.normal *= float(!isinf(result.t));
    return;
}


void worldRayIntersection(
    in  Ray ray, 
    out SphereRayIntersectionResult result
) {    
    SphereRayIntersectionResult curr_result, min_result;
    vec2 t_limits = vec2(0.001f, c_infinity);


    min_result.t      = c_infinity;
    min_result.normal = vec3(0.0f);
    for(int i = 0; i < sceneObjCurrLength; ++i)
    {
        intersection(ray, sceneObject[i], t_limits, curr_result);
        // if(isinf(curr_result.t)) 
        //     continue; /* considering we don't have hundreds of sceneObject, this should be fine without the conditional */

        
        if(curr_result.t < t_limits.y) {
            t_limits.y = curr_result.t;
            min_result = curr_result;
        }
    }
    result = min_result;
}


vec3 defaultRayColor(in Ray ray)
{
    vec3 unit = normalize(ray.dir);
    float t = 0.5f * (unit.y + 1.0f);
    
    return mix(
        vec3(1.0f, 1.0f, 1.0f),
        vec3(0.5f, 0.7f, 1.0f),
        t
    );
}



vec3 CalculatePixelColorDiffuse(in vec2 texelCoord)
{
    SphereRayIntersectionResult possibleHit;
    Ray  cameraRayAtUV;
    vec3 returnedColor;
    uint mulHalf = 0;
    int  i       = 0;
    bool cont    = true;


    cameraRayAtUV = cameraGetRay(sceneCameraTransform, sceneCameraTransform.position, texelCoord);
    for(; i < u_recurseDepth && cont; ++i)
    {
        worldRayIntersection(cameraRayAtUV, possibleHit);
        cont = !isinf(possibleHit.t);
        if(cont) {
            ++mulHalf;
            cameraRayAtUV.origin = rayAt(cameraRayAtUV, possibleHit.t);
            // cameraRayAtUV.dir    = possibleHit.normal + simpleRandUnitSphere(texelCoord, i); /* fake lambertian */
            
            /* true lambertian */
            cameraRayAtUV.dir = simpleRandUnitSphere(texelCoord, i);
            cameraRayAtUV.dir *= mix(-1.0f, 1.0f, dot(cameraRayAtUV.dir, possibleHit.normal) > 0);
        }
    }
    returnedColor = mix(
        defaultRayColor(cameraRayAtUV),
        vec3(0.0f),
        bvec3(i == u_recurseDepth)
    );
    return pow(0.5f, mulHalf) * returnedColor;
}





vec3 CalculatePixelColor(in vec2 texelCoord) 
{
    SphereRayIntersectionResult possibleHit;
    vec3 outColor = vec3(0.0f);
    Ray  cameraRayAtUV;
    vec2 currTexel;
    const float pixel_samples_inv = 1.0f / float(u_samplesPpx);
    const float c_powScatterFactor = pow(u_scatterBase, u_scatterFactor); /* might get rid of, doesn't achieve desired results */


    for(uint sampleIdx = 0; sampleIdx < u_samplesPpx; ++sampleIdx) {
        currTexel = texelCoord + simpleRandUnitSphere(texelCoord, sampleIdx).xz * pixel_samples_inv * pixel_samples_inv;
        outColor += CalculatePixelColorDiffuse(currTexel);
    }

    outColor *= pixel_samples_inv; /* Get Average over All Samples */
    return outColor;
}


void main()
{
    /* intermediates for calculations */
    vec3 finalColor = vec3(0.0f);

    /* Image Output Coordinates (pixel uv coord) */
    ivec2 texelCoord  = ivec2(gl_GlobalInvocationID.xy);
    vec2  texelCoordf = vec2(texelCoord) / vec2(gl_NumWorkGroups.xy * gl_WorkGroupSize.xy);


    finalColor = pow( /* gamma correction */
        CalculatePixelColor(texelCoordf),
        vec3(0.45454545453f)
    );
    imageStore(imageOut, texelCoord, vec4(finalColor, 1.0f));
    return;
}
