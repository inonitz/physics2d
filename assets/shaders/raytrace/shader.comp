#version 460 core
layout(local_size_x =    , local_size_y =    , local_size_z = 1  ) in;
layout(rgba32f, binding = 0) writeonly restrict uniform image2D imageOut;


layout(location = 2) uniform float u_dt;
layout(location = 3) uniform int   samples_per_pixel;


const float c_infinity = 1. / 0.;
const float c_pi = 3.14159265358979323846264338327950288;


float degrees_to_radians(float degrees) { return degrees * c_pi / 180.0f; }


/* Watered-down version of: https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl */
uint hash( uint x ) { // A single iteration of Bob Jenkins' One-At-A-Time hashing algorithm.
    x += ( x << 10u ); x ^= ( x >>  6u );
    x += ( x <<  3u ); x ^= ( x >> 11u );
    x += ( x << 15u ); return x;
}
uint  hash(uvec3 v)          { return hash(v.x ^ hash(v.y) ^ hash(v.z));                        }
float floatConstruct(uint m) { return uintBitsToFloat((m & 0x007FFFFFu) | 0x3F800000u ) - 1.0f; }
float random(vec3 v)         { return floatConstruct(hash(floatBitsToUint(v)));                 }




struct Ray
{
    vec3 origin;
    vec3 dir;
};
vec3 rayAt(in Ray ray, in float t) { return ray.origin + ray.dir * t; }


struct Sphere 
{ 
    vec4 pos_radius; 
};




struct CameraTransform
{
	vec3  position;
	vec2  viewport;
	float focal_length; /* Distance from camera origin to camera Screen */
	int   reserved;
};
Ray cameraGetRay(CameraTransform cam, vec3 rayOrigin, vec2 uv) /* Camera pointing towards -Z axis */
{
    vec3 rayDir;
    rayDir = cam.position - vec3( (vec2(0.5f) - uv) * cam.viewport, cam.focal_length);
    return Ray(rayOrigin, rayDir);
}




layout(std430, binding=1) buffer SceneData
{
    CameraTransform transform;
    uint            max_objects;
    uint            curr_length;
    Sphere          objects[];
};




struct SphereRayIntersectionResult
{
    float t;
    vec3  normal;
};


void intersection(Ray R, Sphere S, in vec2 t_bounds, out SphereRayIntersectionResult result)
{
    float a, b, ac, discrim;
    vec3 tmp;
    vec2 coef;


    tmp = R.origin - S.pos_radius.xyz;
    b = -1.0f * dot(R.dir, tmp); /* calculate -b */
    a = dot(R.dir, R.dir);
    ac = dot(tmp, tmp) - S.pos_radius.w * S.pos_radius.w;

    b  *= (1.0f / a);
    ac *= (1.0f / a);
    discrim = b * b - ac;

    result.t = float(discrim < 0.0f) * c_infinity;
    if(isinf(result.t))
        return;


    coef = vec2(
        b + sqrt(discrim),
        b - sqrt(discrim)
    );
    coef = mix(vec2(c_infinity), coef, 
        bvec2(
            t_bounds.x < coef.x && coef.x < t_bounds.y,
            t_bounds.x < coef.y && coef.y < t_bounds.y
        )
    );
    result.t = min(coef.x, coef.y);
    if(isinf(result.t))
        return;


    result.normal  = rayAt(R, result.t) - S.pos_radius.xyz;
    result.normal *= (1.0f / S.pos_radius.w);
    result.normal *= mix(-1.0f, 1.0f, dot(R.dir, result.normal) < 0.0f); /* set proper direction if vector is outwards/inwards */
    // result.normal *= float(!isinf(result.t));
    return;
}


void worldRayIntersection(in Sphere objects[2], in Ray ray, out SphereRayIntersectionResult result)
{    
    SphereRayIntersectionResult curr_result, min_result;
    vec2 t_limits = vec2(0.001f, c_infinity);


    min_result.t      = c_infinity;
    min_result.normal = vec3(0.0f);
    for(int i = 0; i < 2; ++i)
    {
        intersection(ray, objects[i], t_limits, curr_result);
        // if(isinf(curr_result.t)) 
        //     continue; /* considering we don't have hundreds of objects, this should be fine without the conditional */

        
        if(curr_result.t < t_limits.y) {
            t_limits.y = curr_result.t;
            min_result = curr_result;
        }
    }
    result = min_result;
}


vec3 defaultRayColor(in Ray ray)
{
    vec3 unit = normalize(ray.dir);
    float t = 0.5f * (unit.y + 1.0f);
    
    return mix(
        vec3(1.0f, 1.0f, 1.0f),
        vec3(0.5f, 0.7f, 1.0f),
        t
    );
}





vec3 CalculatePixelColor(in CameraTransform camera, in Sphere objects[2], in vec2 texelCoord)
{
    SphereRayIntersectionResult possibleHit;
    vec3 backgroundCol, hitColor, outColor = hitColor = backgroundCol = vec3(0.0f);
    Ray  cameraRayAtUV;
    vec2 currTexel;
    const float pixel_samples_inv = 1.0f / float(samples_per_pixel);


    for(uint sampleIdx = 0; sampleIdx < samples_per_pixel; ++sampleIdx) {
        currTexel = texelCoord + vec2(clamp(
            random(  vec3(texelCoord, u_dt * sampleIdx)  ),
            0.000f,
            0.999f
        ) * u_dt * pixel_samples_inv);


        /* Find Intersections with Objects in Scene */
        cameraRayAtUV = cameraGetRay(camera, camera.position, currTexel);
        worldRayIntersection(objects, cameraRayAtUV, possibleHit);


        /* Get color from intersection data */
        backgroundCol = defaultRayColor(cameraRayAtUV);
        hitColor      = 0.5f * ( possibleHit.normal + 1.0f );
        outColor += mix(backgroundCol, hitColor, bvec3(!isinf(possibleHit.t)));
    }


    outColor *= pixel_samples_inv; /* Get Average over All Samples */
    return outColor;
}


void main()
{
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec4 value = vec4(
        float(texelCoord.x)/(gl_NumWorkGroups.x),
        float(texelCoord.y)/(gl_NumWorkGroups.y),
        0.0f,
        1.0f
    );
    imageStore(imageOut, texelCoord, value);
    return;
}
